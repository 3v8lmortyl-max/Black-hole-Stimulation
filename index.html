<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>3D Black Hole Visualization</title>
<style>
  html, body { width:100vw; height:100vh; margin:0; background:#000; overflow:hidden; touch-action:none; user-select:none; }
  #container { width: 100vw; height: 100vh; position:fixed; top:0; left:0; }
  #controls { position:fixed; bottom:15px; left:50%; transform:translateX(-50%); color:#fff9; font:12px system-ui; text-align:center; pointer-events:none; z-index:10; }
  #fps { position:fixed; top:10px; right:10px; color:#fff5; font:12px monospace; z-index:10; }
</style>
</head>
<body>
<div id="container"></div>
<div id="controls">Drag to rotate • Pinch to zoom • Two fingers to pan</div>
<div id="fps">FPS: --</div>

<!-- Classic UMD Three.js & Controls - no import/export, works anywhere! -->
<script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
<script>
// Setup
const container = document.getElementById('container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 2;
controls.maxDistance = 100;
controls.enablePan = true;

camera.position.set(0, 8, 25);

// Black Hole: event horizon
const eventHorizon = new THREE.Mesh(
  new THREE.SphereGeometry(2, 48, 48),
  new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.97, transparent:true })
);
scene.add(eventHorizon);

// Accretion disk
const ringGeometry = new THREE.RingGeometry(2.4, 7.5, 64); // Outer ring
const ringMaterial = new THREE.MeshBasicMaterial({
  color: 0xffa500,
  side: THREE.DoubleSide,
  transparent: true,
  opacity: 0.6
});
const accretionDisk = new THREE.Mesh(ringGeometry, ringMaterial);
accretionDisk.rotation.x = Math.PI / 2.1;
scene.add(accretionDisk);

// Glow around event horizon
const glowMaterial = new THREE.MeshBasicMaterial({
  color: 0xffcc88,
  opacity: 0.3,
  transparent: true
});
const glowSphere = new THREE.Mesh(new THREE.SphereGeometry(2.1, 48, 48), glowMaterial);
scene.add(glowSphere);

// Lensing ring
const lensingGeometry = new THREE.RingGeometry(8.5, 9.2, 72);
const lensingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa, opacity: 0.35, transparent: true });
const lens = new THREE.Mesh(lensingGeometry, lensingMaterial);
lens.rotation.x = Math.PI / 2;
scene.add(lens);

// Particles for gas/dust
const particles = new THREE.Group();
scene.add(particles);
for (let i = 0; i < 300; i++) {
  const dist = 3.0 + Math.random() * 13.5;
  const angle = Math.random() * Math.PI * 2;
  const y = (Math.random()-0.5) * 2.2;
  const pGeom = new THREE.SphereGeometry(0.04 + Math.random()*0.05, 6, 6);
  const pMat = new THREE.MeshBasicMaterial({
    color: 0xffbb44 + Math.floor(Math.random()*0x30),
    opacity: 0.6, transparent:true
  });
  const p = new THREE.Mesh(pGeom, pMat);
  p.position.set(Math.cos(angle) * dist, y, Math.sin(angle) * dist);
  p.userData = { angle, dist, y, speed: 0.007 + Math.random()*0.012 };
  particles.add(p);
}

// Background stars
const starsGeom = new THREE.Geometry();
for (let i = 0; i < 180; i++) {
  const d = 60 + Math.random() * 300;
  const t = Math.random() * Math.PI * 2;
  const h = (Math.random() - 0.5) * 120;
  starsGeom.vertices.push(new THREE.Vector3(Math.cos(t)*d, h, Math.sin(t)*d));
}
const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, opacity: 0.65, transparent:true });
const stars = new THREE.Points(starsGeom, starsMat);
scene.add(stars);

// Lighting, just for effect (but not needed for these materials)
scene.add(new THREE.AmbientLight(0xffffff, 0.15));

// Responsive
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animation Loop
let time = 0;
let fps = 0, frameCount = 0, lastTime = performance.now();
function animate() {
  requestAnimationFrame(animate);
  time += 0.012;
  accretionDisk.rotation.z += 0.012;
  glowSphere.material.opacity = 0.3 + 0.13 * Math.sin(time * 2);
  lens.scale.setScalar(1 + Math.sin(time * 2) * 0.035);
  // Animate particles
  particles.children.forEach(p => {
    p.userData.angle += p.userData.speed;
    p.position.x = Math.cos(p.userData.angle) * p.userData.dist;
    p.position.z = Math.sin(p.userData.angle) * p.userData.dist;
  });
  controls.update();
  renderer.render(scene, camera);

  // FPS counter
  frameCount++;
  let now = performance.now();
  if (now - lastTime > 900) {
    fps = Math.round(frameCount*1000/(now-lastTime));
    document.getElementById('fps').textContent = 'FPS: '+fps;
    frameCount = 0;
    lastTime = now;
  }
}
animate();
</script>
</body>
</html>


