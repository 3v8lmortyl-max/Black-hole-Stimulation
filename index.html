<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="theme-color" content="#000000" />
<title>3D Black Hole Visualization</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; background: #000; font-family: system-ui, Arial; user-select: none; touch-action: none; }
  #container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
  #controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.7); font-size: 12px; text-align: center; pointer-events: none; z-index: 10; }
  #fps { position: fixed; top: 10px; right: 10px; color: rgba(255,255,255,0.7); font-size: 12px; font-family: monospace; z-index: 10; }
</style>
</head>
<body>
<div id="container"></div>
<div id="controls">Drag to rotate • Pinch to zoom • Two fingers to pan</div>
<div id="fps">FPS: --</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
const container = document.getElementById('container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);
const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isLowEnd = navigator.hardwareConcurrency <= 4 || navigator.deviceMemory <= 4;
const config = {
  particles: isMobile ? (isLowEnd ? 200 : 500) : 1000,
  diskSegments: isMobile ? 32 : 64,
  textureSize: isMobile ? 256 : 512,
  shadowMapSize: isMobile ? 512 : 1024,
  maxFPS: isMobile ? 30 : 60,
  pixelRatio: Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2)
};
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 3;
controls.maxDistance = 100;
controls.enablePan = true;
controls.panSpeed = isMobile ? 1.5 : 1;
controls.rotateSpeed = isMobile ? 1.2 : 1;
camera.position.set(0, 8, 25);
// Black Hole Event Horizon
const eventHorizonGeometry = new THREE.SphereGeometry(2, config.diskSegments, config.diskSegments);
const eventHorizonMaterial = new THREE.MeshBasicMaterial({
  color: 0x000000,
  transparent: true,
  opacity: 0.95
});
const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
scene.add(eventHorizon);
// Accretion Disk Shader
const accretionShader = {
  uniforms: {
    time: { value: 0 },
    innerRadius: { value: 2.5 },
    outerRadius: { value: 8.0 },
    opacity: { value: 0.8 }
  },
  vertexShader: `
    varying vec2 vUv;
    varying float vDistance;
    void main() {
      vUv = uv;
      vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      vDistance = length(worldPos);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    uniform float innerRadius;
    uniform float outerRadius;
    uniform float opacity;
    varying vec2 vUv;
    varying float vDistance;
    
    void main() {
      vec2 center = vec2(0.5, 0.5);
      float dist = distance(vUv, center) * 2.0;
      
      // Create ring
      if (dist < innerRadius/outerRadius || dist > 1.0) {
        discard;
      }
      
      // Swirling animation
      float angle = atan(vUv.y - center.y, vUv.x - center.x);
      float swirl = sin(angle * 3.0 + dist * 5.0 + time * 2.0) * 0.5 + 0.5;
      
      // Temperature gradient (inner = hotter = whiter)
      float temp = 1.0 - smoothstep(innerRadius/outerRadius, 0.8, dist);
      vec3 coldColor = vec3(1.0, 0.3, 0.1);  // Red
      vec3 warmColor = vec3(1.0, 0.6, 0.2);  // Orange  
      vec3 hotColor = vec3(1.0, 1.0, 0.9);   // White
      
      vec3 color = mix(coldColor, mix(warmColor, hotColor, temp), temp);
      color *= swirl * 1.5;
      
      // Edge fade
      float edgeFade = smoothstep(0.95, 0.85, dist) * smoothstep(innerRadius/outerRadius + 0.05, innerRadius/outerRadius + 0.1, dist);
      
      gl_FragColor = vec4(color, opacity * edgeFade);
    }
  `
};
// Accretion Disk
const diskGeometry = new THREE.RingGeometry(2.5, 8, config.diskSegments, 8);
const diskMaterial = new THREE.ShaderMaterial({
  ...accretionShader,
  transparent: true,
  side: THREE.DoubleSide,
  blending: THREE.AdditiveBlending
});
const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
accretionDisk.rotation.x = -Math.PI / 2 + 0.3;
scene.add(accretionDisk);
// Particle System for gas/dust
const particleCount = config.particles;
const particleGeometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const velocities = new Float32Array(particleCount * 3);
const sizes = new Float32Array(particleCount);
for (let i = 0; i < particleCount; i++) {
  const radius = Math.random() * 15 + 3;
  const angle = Math.random() * Math.PI * 2;
  const height = (Math.random() - 0.5) * 2;
  positions[i * 3] = Math.cos(angle) * radius;
  positions[i * 3 + 1] = height;
  positions[i * 3 + 2] = Math.sin(angle) * radius;
  velocities[i * 3] = -Math.sin(angle) * 0.01;
  velocities[i * 3 + 1] = 0;
  velocities[i * 3 + 2] = Math.cos(angle) * 0.01;
  sizes[i] = Math.random() * 2 + 1;
}
particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
const particleMaterial = new THREE.PointsMaterial({
  color: 0xffaa44,
  size: 0.1,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending,
  sizeAttenuation: true
});
const particles = new THREE.Points(particleGeometry, particleMaterial);
scene.add(particles);
// Gravitational Lensing Ring
const lensGeometry = new THREE.RingGeometry(9, 10, config.diskSegments);
const lensMaterial = new THREE.MeshBasicMaterial({
  color: 0xffdd88,
  transparent: true,
  opacity: 0.3,
  side: THREE.DoubleSide
});
const lensingRing = new THREE.Mesh(lensGeometry, lensMaterial);
lensingRing.rotation.x = -Math.PI / 2;
scene.add(lensingRing);
// Background Stars
const starGeometry = new THREE.BufferGeometry();
const starCount = isMobile ? 200 : 500;
const starPositions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) {
  starPositions[i * 3] = (Math.random() - 0.5) * 400;
  starPositions[i * 3 + 1] = (Math.random() - 0.5) * 400;
  starPositions[i * 3 + 2] = (Math.random() - 0.5) * 400;
}
starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const starMaterial = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 0.5,
  transparent: true,
  opacity: 0.8
});
const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);
// Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffaa44, 2, 50);
pointLight.position.set(5, 5, 5);
if (!isLowEnd) {
  pointLight.castShadow = true;
  pointLight.shadow.mapSize.width = config.shadowMapSize;
  pointLight.shadow.mapSize.height = config.shadowMapSize;
}
scene.add(pointLight);
// FPS Counter
let fps = 0;
let frameCount = 0;
let lastTime = performance.now();
function updateFPS() {
  frameCount++;
  const now = performance.now();
  if (now - lastTime >= 1000) {
    fps = Math.round((frameCount * 1000) / (now - lastTime));
    frameCount = 0;
    lastTime = now;
    document.getElementById('fps').textContent = `FPS: ${fps}`;
  }
}
// Animation variables
let time = 0;
const clock = new THREE.Clock();
// Animation loop
function animate() {
  requestAnimationFrame(animate);
  time = clock.getElapsedTime();
  diskMaterial.uniforms.time.value = time;
  accretionDisk.rotation.z += 0.005;
  const positions = particles.geometry.attributes.position.array;
  for (let i = 0; i < particleCount; i++) {
    const x = positions[i * 3];
    const z = positions[i * 3 + 2];
    const radius = Math.sqrt(x * x + z * z);
    if (radius > 2.5) {
      const speed = 0.01 / radius;
      const angle = Math.atan2(z, x) + speed;
      positions[i * 3] = Math.cos(angle) * radius;
      positions[i * 3 + 2] = Math.sin(angle) * radius;
    }
  }
  particles.geometry.attributes.position.needsUpdate = true;
  lensingRing.scale.setScalar(1 + Math.sin(time * 2) * 0.1);
  controls.update();
  renderer.render(scene, camera);
  updateFPS();
}
// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
// Hide loading screen and start animation
document.getElementById('loading').style.display = 'none';
animate();
// Performance monitoring - reduce quality if FPS drops
setInterval(() => {
  if (fps < 20 && fps > 0) {
    particles.visible = false;
    console.log('Performance optimization: Hiding particles');
  }
}, 5000);
</script>
</body>
</html>

